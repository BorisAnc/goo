{"name":"Goo","tagline":"Graph Oriented Objects for Ruby (Goo)","body":"# _Graph Oriented Objects_ for Ruby  (Goo)\r\n\r\n*Goo* is a Ruby library that provides ORM-alike capabilities to interact with [RDF](http://en.wikipedia.org/wiki/Resource_Description_Framework)/[SPARQL](http://en.wikipedia.org/wiki/SPARQL) backends. *Goo* provides a DSL for defining schemas for objects and controls how they get validated, serialized, saved and retrieved from the triplestore. Using RDF and SPARQL for large-scale applications creates challenges in terms of both scalability and technology adoption. We designed Goo with two main objectives:\r\n\r\n- *Goo* abstracts SPARQL in a way that developers do not need to be SPARQL experts to efficiently handle large RDF graphs.\r\n\r\n- *Goo* was initially design to serve [BioPortal](http://bioportal.bioontology.org/) growing REST traffic. BioPortal's REST API provides access to hundreds of millions of Biomedical artifacts. Scalability and efficiency is at the core of *Goo's* design.\r\n\r\n\r\n## Schema Definitions (DSL)\r\n\r\n###Basic Definitions\r\n\r\n*Goo* models are defined by extending [Resource](/docs/Goo/Base/Resource) and providing one [model]() definition and [attribute]() definitions. The example below provides defines a `User` model with two attributes `username` and `email`. In this model:\r\n\r\n```ruby\r\nrequire 'goo'\r\n\r\nclass User < Goo::Base::Resource\r\n  model :user, name_with: :username\r\n  attribute :username, enforce: [:existence, :unique]\r\n  attribute :email, enforce: [:existence, :email]\r\nend\r\n```\r\n\r\n- `:name_with` tells this object to take the value of the `username` attribute to generate a URI that uniquely identifies an instance. `:name_with` also accepts a lambda function for flexible naming policies, for example: \r\n\r\n```ruby\r\nname_with: lambda { |u| RDF::URI.new(\"http:// .... /some/uri}\" }\r\n```\r\n\r\n- `:enforce` is the option to establish validations at the attribute level. It accepts an array of elements. In this example there are three different validations:\r\n\r\n    * `:existence` to force the attribute to hold a value. This attribute cannot be `nil`.\r\n\r\n    * `:unique` to force the value of the attribute to be unique across all the instances of the same type.\r\n\r\n    * `:email` to force the value of the attribute to be an string that is a valid email.\r\n\r\n\r\n### Object Dependencies\r\n\r\nWith `:enforce` one can tell *Goo* that that attribute should hold instance values of other *Goo* type.  For instance, say that: _A user can be assigned one or many roles_ and the `Role` model looks like this:\r\n\r\n\r\n```ruby\r\nclass Role < Goo::Base::Resource\r\n  model :role, name_with: :code\r\n  attribute :code, enforce: [:existence, :unique]\r\nend\r\n```\r\n\r\nWe now add a new attribute `:roles` in `User`. The `:enforce` setting for this attribute include: `:list` to tell the system that this attribute can hold array values and `:role`; `:role` is a symbol that refers to some other *Goo* type. *Goo* will enforce all the values of this attribute to be instances of the `Role` type.\r\n\r\n```ruby \r\nattribute :roles, enforce: [:list, :role, :existence]\r\n#Notice that this attribute complements the above User definition.\r\n```\r\n\r\nWe can also connect back `Role` to `User` using the `inverse` setting. Say you want to retrieve all the users that are assigned a certain role. To be able to navigate the graph both ways we need to provide the inverse relation. The following definition tells `Goo` that when looking at a `Role` instance one can retrieve users by inversing the attribute `roles` from the user instance.\r\n\r\n```ruby\r\nattribute :users, inverse: { on: User, attribute: :roles }\r\n#Notice that this attribute complements the above Role definition.\r\n```\r\n\r\n### Validators List\r\n\r\nThe are a variety of built-in validators that can be used with the `enforce` option, these include: `:string`, `:date_time`, `:float`, `:integer`, `:list`, `:unique`, `:existence`, `:min`, `:max`, `:email`, `:uri`, `:boolean`. \r\n\r\nOptionally one also can provide a lambda for implementing custom validations.\r\n\r\n### Other Model and Attribute Options\r\n\r\n- `:namespace` both model and attribute definitions accept the `:namespace` option to refer to specific vocabularies in our application (see [Configuration](#Configuration) for namespace definitions). For instance:\r\n\r\n```ruby\r\nmodel :person, namespace: :foaf, name_with: ..\r\n```\r\n\r\n- `:default` to provide default values to an attribute via lambda functions. For instance:\r\n\r\n```ruby\r\nattribute :created, enforce: [ DateTime ],\r\n        default: lambda { |record| DateTime.now }\r\n```\r\n\r\n- `:property`: this setting allow us to map attributes to RDF predicates and use different names. For instance, say we want to have an attribute named `parents` that maps to `rdfs:subClassOf` in the triple store:\r\n\r\n```ruby\r\nattribute :parents, namespace: :rdfs, property: :subClassOf,\r\n                    enforce: [:class, :list]\r\n```\r\n\r\n##Saving, updating and deleting.\r\n\r\n- Instance creation:\r\n\r\n```ruby\r\nu = User.new\r\nu.username = \"paul\"\r\nu.save \r\n#save throws NotValidException \r\n#in case any validator breaks\r\n```\r\n\r\n- Testing for valid objects: \r\n\r\n```ruby\r\nu = User.new\r\nu.name = \"paul\"\r\nif !u.valid?\r\n puts u.errors\r\nend\r\n```\r\n\r\n- Updating an instance:\r\n\r\n```ruby\r\nu = User.find(\"paul\").first\r\n#or\r\nu = User.where(username: \"paul\").all\r\n\r\n#update the object with an array of roles\r\nu.roles = [Roles.find(\"admin\").first]\r\nu.save \r\n```\r\n\r\nNote: `.find(\"paul\")` can be used because `User` has `username` as `name_with` setting, in addition `username` is `unique`. This allow us to use this shortcut.\r\n\r\n- Deleting:\r\n\r\n```ruby\r\n#delete `paul`\r\nUser.find(\"paul\").first.delete\r\n\r\n#delete all users\r\nUser.where.all.each do |u|\r\n  u.delete\r\nend\r\n```\r\n\r\n##Querying\r\n\r\n*Goo's* provides a flexible API for querying the SPARQL backend. There are two main `Resource` calls for creating queries: `Resource.find` and `Resource.where` \r\n\r\n###Resource.find - searching single instances\r\n\r\n- Getting a resource reference:\r\n\r\n```ruby\r\nu = User.find(RDF::URI.new(\"http://example.org/paul\")).first\r\nu.is_a?(User) #true\r\nputs u.username #throws AttributeNotLoaded exception\r\n```\r\n\r\n*Goo* by default does not attach any attribute values to an instance when retrieving data. This is to improve efficiency by only retrieving the attributes we care about in our application. To change this behaviour we can always overload `find` our *Goo* types.\r\n\r\nWe can attach object attributes by chaining `include` calls:\r\n\r\n```ruby\r\nuser_id = RDF::URI.new(\"http://example.org/paul\")\r\n\r\n#include username\r\nu = User.find(user_id).include(:username).first\r\n\r\n#include username and roles\r\nu = User.find(user_id).include(:username, :roles).first\r\n\r\n#equivalent\r\nu = User.find(user_id).include(:username).include(:roles).first\r\n\r\n#embed attributes from dependent objects\r\n#from roles include their codes\r\nu = User.find(user_id).include(roles: [:code]).first\r\nputs u.roles[0].code #\"admin\"\r\n\r\n#include all the attributes - except inverse attributes\r\nadmin = Role.find(\"admin\").include(Role.attributes).first\r\n\r\n#include all the attributes - including inverse\r\nadmin = Role.find(\"admin\").include(Role.attributes(:all)).first\r\n\r\n```\r\n\r\nNote: `include` is also avalaible for the `Resource.where` API call.\r\n\r\n###Resource.where - Graph Pattern Matching\r\n\r\n`Resource.where` offers an easy way to perform complex graph matching operations.\r\n\r\n```ruby\r\n#retrieve all the users with name paul that have the admin role.\r\nusers = User.where(lastname: \"paul\", role: [ Role.find(\"admin\").first ]).all\r\n\r\n#same and attach attributes\r\nusers = User.where(lastname: \"paul\", role: Role.find(\"admin\").first)\r\n                    include(:username, :birthdate).all\r\n\r\n```\r\n\r\nThe options passed into `where` reassembles a graph matching structure and can be read as follows;\r\n\r\n```ruby\r\n#match 'lastname' edges that sink into literal objects \"paul\"\r\n[ lastname: \"paul\" ,\r\n#AND match 'role' edges that sink into 'admin' objects.\r\nrole: Role.find(\"admin\").first ]\r\n```\r\n\r\n*Goo* allows for more complex scenarios. Say we had an scenario where our models are `Student`, `Programs`, `Category` and `University` and the relations between types:\r\n\r\n- Students enrol programs, ie: _Susan enrols Bioinformatics_\r\n- Programs have categories. ie: _Bioinformatics has categories Biology and Computer Science_ \r\n- Programs belong to universities, ie: _Bioinformatics is at Stanford_\r\n\r\n```ruby\r\n#retrieve all student enrolled in a program that has categories \r\n# with  code \"Biology\" and \"Chemistry\"\r\nstudents = Student.where(enrolled: [category: [ code: \"Biology\" ]])\r\n                    .and(enrolled: [category: [ code: \"Chemistry\" ]]).all\r\n\r\n#retrieve all students enrolled in a program that belongs to a university\r\n#that is named \"Stanford\" and attach student names, and embed programs\r\n#and programs should be retrieved with their names.\r\nstudents = Student.where(enrolled: [university: [name: \"Stanford\"]])\r\n            .include(:name)\r\n            .include(enrolled: [:name]).all\r\n\r\n#We can also perform OR operations. Retrieve programs that have\r\n# category codes \"Medicine\" or \"Engineering\"\r\nprs = Program.where(category: [code: \"Medicine\"])\r\n                    .or(category: [code: \"Engineering\"]).all\r\n\r\n#From these 4 students tell me who are enrolled in programs that \r\n#are categorized as Medicine AND Chemistry\r\nmedicine = Category.find(\"Medicine\").first\r\nchemistry = Category.find(\"Chemistry\").first\r\nst = Student.where(name: \"Daniel\")\r\n              .or(name: \"Louis\")\r\n              .or(name: \"Lee\")\r\n              .or(name: \"John\")\r\n              .and(enrolled: [category: medicine])\r\n              .and(enrolled: [category: chemistry]).all\r\n```\r\n\r\nNote: for a slightly more complex but similar scenario see ./test/test_where.rb\r\n\r\n\r\n###Filters and Range Queries\r\n```ruby\r\n#students born later than ...\r\nf = Goo::Filter.new(:birth_date) > DateTime.parse('1978-01-03')\r\nst = Student.where.filter(f).all\r\n\r\n#students born between two dates\r\nf = (Goo::Filter.new(:birth_date) <= DateTime.parse('1978-01-01'))\r\n      .or(Goo::Filter.new(:birth_date) >= DateTime.parse('1978-01-07'))\r\nst = Student.where.filter(f).all\r\n\r\n#students enrolled in programs with more than 8 credits\r\nf = Goo::Filter.new(enrolled: [ :credits ]) > 8\r\nst = Student.where.filter(f).all\r\n```\r\n\r\nSay our scenario has an attribute `award` in `Student` to record a list of awards that a student has earned. Now we want to find all the students with no wining awards.\r\n\r\n```ruby\r\n#students without awards\r\nf = Goo::Filter.new(:awards).unbound\r\nst = Student.where.filter(f)\r\n                  .include(:name)\r\n                  .all\r\n```\r\n\r\n\r\n###Working with unknown attributes - schemaless objects\r\n\r\nIt is often the case when dealing with Linked Data and RDF that might not be able to map all RDF attributes into application attributes but still we might want to be able to retrieve them. Unknown or unmapped attributes can be retrieved with any of the retrieval methods (find or where) by including the symbol `:unmapped`. When doing so the models wil be retrieved with an attribute `@unmmaped`, that attribute is `Hash` where the keys are the RDF predicates of that resources and the values arrays of objects.\r\n\r\n```ruby\r\n p = Person.find(RDF::URI.new(SOME_URI)).include(:unmapped).first\r\n p.unmmaped.each do |property,values|\r\n   puts \"handle unknown attributes\"\r\n end\r\n```\r\n\r\nWe can search on known attributes and at retrieve unmmaped predicates:\r\n\r\n```ruby\r\nsts = Student.where(enrolled: [university: [name: \"Stanford\"]])\r\n            .include(:unmapped).all\r\n```\r\n\r\nThis capability is important when dealing with scenarios of data integration of Linked Data resources.\r\n\r\n\r\n\r\n##Configuration\r\nConfiguration is set by passing code block to `Goo.configure`. The `conf` object responds to calls to:\r\n\r\n  * add_namespace: With this call we set the relation between Ruby symbols used in the DSL and RDF Vocabularies.\r\n  * add_sparql_backend: This call is to provide the endpoints of the SPARQL server. There are three endpoints `query`, `update` and `data`.\r\n  * add_redis_backend: The Redis host can be optionally added using this call. This is only required if indexes are used.\r\n  \r\n\r\n```ruby\r\nGoo.configure do |conf|\r\n    conf.add_namespace(:omv, RDF::Vocabulary.new(\"http://omv.org/ontology/\"))\r\n    conf.add_namespace(:skos, RDF::Vocabulary.new(\"http://www.w3.org/2004/02/skos/core#\"))\r\n    conf.add_namespace(:owl, RDF::Vocabulary.new(\"http://www.w3.org/2002/07/owl#\"))\r\n    conf.add_namespace(:rdfs, RDF::Vocabulary.new(\"http://www.w3.org/2000/01/rdf-schema#\"))\r\n    conf.add_namespace(:goo, RDF::Vocabulary.new(\"http://goo.org/default/\"),default=true)\r\n    conf.add_sparql_backend(:main, query: \"http://localhost:9000/sparql/\",\r\n                            data: \"http://localhost:9000/data/\",\r\n                            update: \"http://localhost:9000/update/\",\r\n                            options: { rules: :NONE })\r\n    conf.add_redis_backend(:host => \"localhost\")\r\nend\r\n```\r\n\r\n\r\n##Advance Topics\r\n\r\n###Collections and Named Graphs\r\n\r\nCollections allow to save objects in a specific named graph and information can be attached to the named to implement data provenance. So say you have terms that belong to a website and the website URL is going to be the ID of the named graph. Additionally we have some data about the web site.\r\n\r\n```ruby\r\nrequire 'goo'\r\n\r\nclass Term < Goo::Base::Resource\r\n  model :term, name_with: :name, collection: :website\r\n  attribute :name, enforce: [:existence, :unique]\r\n  attribute :extracted_from, enforce: [:website]\r\nend\r\n\r\nclass Website < Goo::Base::Resource\r\n   model :website, name_with: :url\r\n   attribute :url, enforce [:existence, :unique]\r\n   attribute :author, enforce [:user]\r\nend\r\n\r\nwebsite = Website.new(url: \"http://example.com\", author: some_user).save\r\n\r\n#saving\r\nt = Term.new(name: \"some term\", extracted_from: website).save\r\n\r\n#searching\r\nterms = Term.where( some_search_pattern ).in(website).all\r\n\r\n```\r\n\r\nChaining the search with `.in( provenance_object )` will constrain the search to just the graph of a specific object. \r\n\r\n###Caching and Indexing\r\nWhen implementing pagination, we normally return statistical information about the number of resources across all pages, number of pages, links to next and previous pages and the information about the resources contained in the current page. In SPARQL, pagination happens at the level of triples. In Goo, we provide built-in capabilities to cache this pagination-related data. This approach works best for resources that are mostly read-only or for resources where getting the most recent information is not critical (e.g., the ontology information)\r\nThe example below shows the indexing of ontology classes by label and its use to access a page of information.\r\n\r\n```ruby\r\nontology = Ontology.find(RDF::URI.new(ONT_ID))\r\n#index\r\nKlass.in(ontology).order_by(label: :asc).index_as(\"my_index\")\r\n\r\n#search with the index\r\nfirst_page = Klass.in(ontology).with_index(\"my_index\")\r\n              .include(:label, :synonym).page(1, 100)\r\n```\r\n\r\n###Fast retrieval of read-only objects\r\n\r\n In most dynamic languages, objects can be expensive data structures and one can save memory and CPU time by using cheaper data containers. The Ruby platform provides the `Struct` class. Simple benchmarks show that the instantiation of `Struct` objects can be up to 63% faster than Goo Resource objects. This is mainly due to the internal objects that Goo maintains to track each object's state. These internal objects are of no use when the application is only reading and not writing. \r\nTo trigger the retrieval of read-only objects in Goo we call the `.read_only` when issuing a query, i.e:\r\n\r\n```ruby\r\nUser.where.include(:username, :email).read_only\r\n```\r\n\r\n###Aggregators\r\n\r\ndocumentation TODO just an example ...\r\n\r\n\r\n###Profiler\r\n\r\nImplemented … documentation TODO\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}